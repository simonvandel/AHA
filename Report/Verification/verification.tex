%mainfile: ../master.tex
\chapter{Test and Verification}
In this section a description of the testing performed on the system to verify that it, to a satisfying degree, solves the problem solution. Along with this description a number of alternatives will also be discussed in relation to why they weren't chosen.

\section{Testing}
To test the system, we set up a simple test system in a controlled environment, consisting of just one sensor an emulatable action and the server. Then for *\ranote{insert how many hours we actually performed it} we performed a deliberate pattern. A pattern here consisting of an action and a change in the sensor state. Then we stopped performing the action, and if the system took over and performed the action when the sensor state changed it would be considered successful. This is the simplest use case for the system, but shows that our learning procedure in the learning subsystem can recognise a pattern which is also the smallest requirement for the system to be deemed working. Once the learning subsystem has been tested the real-time critical part of the system (from the embedded subsystem through the reasoner back to the embedded subsystem) were tested \ranote{Real time test lingo? Ignore? Specific real time test method?}...*
\\\\
Once it has been verified the system can learn a pattern and can reason and subsequently perform the appropriate action within a *time frame*\ranote{see last note} the second key component of the system is the ability to adapt to a change in patterns. So following the first test, i.e. the system has a learned pattern, a different overlapping pattern were performed for an hour. Then we checked if the system had adapted, if not the pattern were performed for another hour this were repeated until the system adapted. While it is important noting how quickly the system adapts to change once it has been confirmed the system does adapt the speed with which it does can be changed.
\subsection{Results and Specific Setup}
\input{Verification/tests.tex}

\section{Alternative tests}
The first alternative which were considered is a real world use case. In this test a system would be setup in one or more users homes for a given set of time. Once the test had finished the log data from the system along with user testimony would determine the performance of the system. This test is time consuming, because the system would need to be live for an extended period of time to learn user patterns on a daily, weekly, or longer scale. The log data can also be difficult and time consuming to analyse because the large amount of data processed by the system and the difficult to visually represent machine learning model used.
\\\\
Unit tests is another alternative which ensures some stability in the system. But for a system that relies on random data with patterns, which is difficult to produce programmatically, unit tests does not show how well the system performs only that it produces some data. A preliminary unit test were performed on the system. In this test the system were given a specific set of sensor states a set number of times and then checked whether the system produced the expected action given a sensor state.

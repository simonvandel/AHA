\section{XBee}
As discussed earlier, the communication in the system will be done using XBee modules, using the ZigBee protocol. In this section, the specific implementation in this system will be discussed, along with the impact this choice could have on the real-time system requirements.

\subsection{Sending Modes}
The XBee module has two different control interfaces transparent- and API mode.
\subsubsection{Transparent Mode}
In transparent mode, whatever the xbee module receives on its serial input pins, it immediately sends over the network to the address specified in the firmware settings. This means that the time it takes to send data is insignificant. \ranote(Put the specifics of this result in an appendix?) A single message can be sent in under 2 ms, however, because there is no administration of the network, spamming the network will increase the time to send to upwards of 60 ms. Unless the client/host program handles it, there is no guarantee that each package is received. \cref{arduino_at_mode}
In this mode a lot of messages can be sent quickly, but with little control.
%https://docs.digi.com/display/WirelessConnectivityKit/Command+mode
\subsubsection{API Mode}
In API mode, the XBee module buffers the data it receives on its serial pins, to a limit of 64 bytes, until a specific command is received. If it receives a send command, it packages the data in its buffer in the ZigBee protocol\footnote(The zigbee protocol is IEEE 802.15.4 based), which includes the module's address and network information, and makes the receiving module send back a received acknowledgement (except if broadcasting). In addition the protocol implements either a beacon frame or a exponential back off algorithm. A beacon frame asks for permission to use the network, then the coordinator of the network makes sure no other modules transmits while the asking module uses it. An exponential back off algorithm waits a random amount of time before re-sending the collided package, if the collision happens again it waits an incremental amount of random time. The xbee documentation does not specify which of these methods is implemented however the beacon frame is not definable in xbee, so it is assumed that the xbee module uses exponential back off. This process creates overhead, resulting in the time to send (including receiving the acknowledgement) taking up to 60 ms. However, it is possible to ignore the acknowledgement, this means the time to send is lowered significantly\ranote{lav testen eller tr�k et tal op af hatten? eller lad det st� som nu?}. 
\subsection{Implementation}
While there should be no single sensor state, so significant, that the system would take a considerable precision hit, in the case it gets lost. In the testing of the modules, the time to send did not slow down the system, to a degree that made it break the real-time requirement. The actions which the server sends needs to always reach its client, for this reason this system uses the API mode.
\subsubsection{Aruino Implementation}
Using the official XBee library\cref{xbee_arduino_library} for Arduino, simple calls to the Arduino is facilitated through the C++ objects given in the library. Sending is handled by passing a send command  to the module, the system then waits a maximum of 250 ms for a acknowledgement.
Receiving data is done, using predefined call back methods from the library. A single method call ensures that every kind of package is processed, and the method for handling the relevant packages can be overwritten. The relevant package for the Arduino is the zbReceive, i.e. the package that contains user defined data. On the Arduino, the only possible data, this can contain, is an action, so the overwritten method decodes and performs the appropriate action.
%https://github.com/andrewrapp/xbee-arduino
